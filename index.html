<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="main.css" />
    <style>
      body {
        background-color: #ccc;
        color: #000;
      }

      a {
        color: #f00;
      }
    </style>
  </head>

  <body>
    <div id="info">
      <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
      Room cube
    </div>

    <script type="module">
      import * as THREE from "./lib/three.module.js";

      import { OrbitControls } from "./lib/OrbitControls.js";

      var scene = new THREE.Scene();
      var cube = null;
      var SCREEN_W, SCREEN_H;
      SCREEN_W = window.innerWidth;
      SCREEN_H = window.innerHeight;

      var left, bottom, width, height;

      var camera_pivot = new THREE.Object3D();

      var camera = new THREE.PerspectiveCamera(
        80,
        window.innerWidth / window.innerHeight,
        1,
        10000
      );

      var renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      document.addEventListener("keydown", onDocumentKeyDown, false);

      var controls = new OrbitControls(camera, renderer.domElement);

      scene.add(camera_pivot);
      camera_pivot.add(camera);

      camera.position.set(50, 50, 500);
      camera.lookAt(camera_pivot.position);

      controls.update();

      controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
      controls.dampingFactor = 0.05;

      controls.screenSpacePanning = false;

      controls.minDistance = 100;
      controls.maxDistance = 500;

      controls.maxPolarAngle = Math.PI / 2;

      var topCamera = new THREE.OrthographicCamera(
        -400,
        400,
        400,
        -400,
        10,
        2000
      );
      topCamera.position.set(0, 450, 0);
      topCamera.up.set(0, 0, -1);
      topCamera.lookAt(new THREE.Vector3(0, 0, 0));

      var texture = new THREE.TextureLoader().load("texture/crate.gif");
      var texture2 = new THREE.TextureLoader().load("texture/window.png");

      var material = new THREE.MeshBasicMaterial({
        color: 0x00ff00,
        side: THREE.DoubleSide,
      });

      var floor = new THREE.Mesh(
        new THREE.PlaneGeometry(300, 300, 100, 100),
        material
      );

      floor.position.y = -100;
      floor.rotation.x = Math.PI / 2;

      scene.add(floor);

      var backWall = new THREE.Mesh(
        new THREE.PlaneGeometry(300, 200, 100, 100),
        new THREE.MeshBasicMaterial({ color: 0x751e75, side: THREE.DoubleSide })
      );
      backWall.position.z = -150;
      scene.add(backWall);

      var win = new THREE.Mesh(
        new THREE.PlaneGeometry(50, 50, 100, 100),
        new THREE.MeshBasicMaterial({ map: texture2 })
      );
      win.position.z = -150;
      scene.add(win);

      var ceiling = new THREE.Mesh(
        new THREE.PlaneGeometry(300, 300, 100, 100),
        new THREE.MeshBasicMaterial({ color: 0x42ecf5 })
      );
      ceiling.side = THREE.DoubleSide;
      ceiling.position.y = 100;
      ceiling.rotation.x = 90 * (Math.PI / 180);
      scene.add(ceiling);

      var leftWall = new THREE.Mesh(
        new THREE.PlaneGeometry(300, 200, 100, 100),
        new THREE.MeshBasicMaterial({ color: 0xf5f238, side: THREE.DoubleSide })
      );
      leftWall.position.x = 150;
      leftWall.rotation.y = -90 * (Math.PI / 180);
      scene.add(leftWall);

      var rightWall = new THREE.Mesh(
        new THREE.PlaneGeometry(300, 200, 100, 100),
        new THREE.MeshBasicMaterial({ color: 0xf5f238, side: THREE.DoubleSide })
      );
      rightWall.position.x = -150;
      rightWall.rotation.y = 90 * (Math.PI / 180);

      scene.add(rightWall);

      cube = new THREE.Mesh(
        new THREE.BoxBufferGeometry(50, 50, 100),
        new THREE.MeshBasicMaterial({ map: texture })
      );
      cube.position.y = 10;

      cube.position.z = 250;

      scene.add(cube);

      var animate = function () {
        requestAnimationFrame(animate);

        left = 1;
        bottom = 1;
        width = 0.5 * SCREEN_W - 2;
        height = SCREEN_H - 2;
        renderer.setViewport(left, bottom, width, height);
        renderer.setScissor(left, bottom, width, height);
        renderer.enableScissorTest(true);
        topCamera.aspect = width / height;
        topCamera.updateProjectionMatrix();
        renderer.render(scene, topCamera);

        left = 0.5 * SCREEN_W + 1;
        bottom = 1;
        width = 0.5 * SCREEN_W - 2;
        height = SCREEN_H - 2;
        renderer.setViewport(left, bottom, width, height);
        renderer.setScissor(left, bottom, width, height);
        renderer.enableScissorTest(true); // clip out "viewport"
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        controls.update();
        renderer.render(scene, camera);
        // scene.rotation.y = 0.25;
      };

      function onDocumentKeyDown(event) {
        var pos = cube.position.z;
        var keyCode = event.which;
        var r = 10;
        if (keyCode == 87) {
          // if (pos > -100) {
          cube.position.z -= 10;
          // }
        } else if (keyCode == 83) {
          if (pos < 350) {
            cube.position.z += 10;
          }
        }
      }

      animate();
    </script>
  </body>
</html>
